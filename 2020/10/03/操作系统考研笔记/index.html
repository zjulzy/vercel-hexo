<!DOCTYPE html><html lang="zh-cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统考研笔记 | Hexo</title><meta name="author" content="lenmain"><meta name="copyright" content="lenmain"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="一. 操作系统引论二. 进程的描述和控制三. 处理机调度和死锁四. 存储器管理五. 虚拟存储器六. 输入输出系统七. 文件管理八. 磁盘存储器的管理九. 操作系统接口十. 多处理器操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统考研笔记">
<meta property="og:url" content="https://vercel-hexo-ten.vercel.app/2020/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一. 操作系统引论二. 进程的描述和控制三. 处理机调度和死锁四. 存储器管理五. 虚拟存储器六. 输入输出系统七. 文件管理八. 磁盘存储器的管理九. 操作系统接口十. 多处理器操作系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-10-03T02:43:19.000Z">
<meta property="article:modified_time" content="2020-10-03T02:54:01.753Z">
<meta property="article:author" content="lenmain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vercel-hexo-ten.vercel.app/2020/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-03 10:54:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">8</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 操作系统的目标和作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 操作系统的发展过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 操作系统的基本特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 操作系统的基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-OS%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 OS的结构设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">2. 进程的描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 进程的控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 进程管理中的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 进程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1IPC"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 进程通信IPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 线程的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 线程的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">3. 处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 处理机调度的层次和调度算法的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 作业与作业调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 实时调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%AD%BB%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 预防死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%88%E6%9C%80%E5%A4%A7%E9%9C%80%E6%B1%82-%E5%B7%B2%E5%88%86%E9%85%8D%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 避免死锁（最大需求+已分配）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E6%8E%92%E9%99%A4"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 死锁的检测和排除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">4. 存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 存储器的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 程序的装入和链接：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 连续分配存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%EF%BC%88swapping%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 交换技术（swapping）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 分页存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 分段存储管理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 段页式存储管理方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">5. 虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2  请求分页存储管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 页面置换算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">6. 输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 I&#x2F;O系统的功能，模型和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-I-O%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 I&#x2F;O设备和设备控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 中断机制和中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 设备驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84I-O%E8%BD%AF%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 与设备无关的I&#x2F;O软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E7%94%A8%E6%88%B7%E5%B1%82%E7%9A%84I-O%E8%BD%AF%E4%BB%B6"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 用户层的I&#x2F;O软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 缓冲区管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">6.8.</span> <span class="toc-text">6.8 磁盘存储器的性能和调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">7. 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 文件和文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 文件的逻辑结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 文件目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 文件共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 文件保护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">8. 磁盘存储器的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%A4%96%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 外存的组织方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 文件存储空间的管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%8F%90%E9%AB%98%E7%A3%81%E7%9B%98I-O%E9%80%9F%E5%BA%A6%E7%9A%84%E9%80%94%E5%BE%84"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 提高磁盘I&#x2F;O速度的途径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E6%8F%90%E9%AB%98%E7%A3%81%E7%9B%98%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 提高磁盘可靠性的技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">9. 操作系统接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">10. 多处理机操作系统</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">操作系统考研笔记</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-03T02:43:19.000Z" title="Created 2020-10-03 10:43:19">2020-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-03T02:54:01.753Z" title="Updated 2020-10-03 10:54:01">2020-10-03</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>一. 操作系统引论<br>二. 进程的描述和控制<br>三. 处理机调度和死锁<br>四. 存储器管理<br>五. 虚拟存储器<br>六. 输入输出系统<br>七. 文件管理<br>八. 磁盘存储器的管理<br>九. 操作系统接口<br>十. 多处理器操作系统  </p>
</blockquote>
<a id="more"></a>

<h1 id="1-操作系统引论"><a href="#1-操作系统引论" class="headerlink" title="1. 操作系统引论"></a>1. 操作系统引论</h1><h2 id="1-1-操作系统的目标和作用"><a href="#1-1-操作系统的目标和作用" class="headerlink" title="1.1 操作系统的目标和作用"></a>1.1 操作系统的目标和作用</h2><ul>
<li><p>操作系统的目标：方便性，有效性，可扩充性，开放性</p>
</li>
<li><p>操作系统的作用：OS作为用户与计算机硬件系统之间的接口, 计算机资源的管理者, 实现了计算机资源的抽象</p>
</li>
</ul>
<h2 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h2><ul>
<li>未配置操作系统的计算机系统</li>
<li>单道批处理系统</li>
<li>多道批处理系统：资源利用率高，系统吞吐量大，平均周转时间长，没有交互能力</li>
<li>分时系统：多路性，独立性，及时性，交互性</li>
<li>实时系统</li>
</ul>
<h2 id="1-3-操作系统的基本特征"><a href="#1-3-操作系统的基本特征" class="headerlink" title="1.3 操作系统的基本特征"></a>1.3 操作系统的基本特征</h2><ul>
<li>并行和并发</li>
</ul>
<table>
<thead>
<tr>
<th align="center">并行</th>
<th align="center">两个或多个事件在同一时刻发生</th>
</tr>
</thead>
<tbody><tr>
<td align="center">并发</td>
<td align="center">两个或多个事件在同一时间间隔发生</td>
</tr>
</tbody></table>
<ul>
<li><p>引入进程</p>
</li>
<li><p>共享：互斥共享方式，同时访问方式</p>
</li>
<li><p>虚拟：时分复用与空分复用</p>
</li>
<li><p>异步</p>
</li>
</ul>
<h2 id="1-4-操作系统的基本功能"><a href="#1-4-操作系统的基本功能" class="headerlink" title="1.4 操作系统的基本功能"></a>1.4 操作系统的基本功能</h2><ul>
<li>进程控制：为使作业并发执行，为其创建一个或多个进程，并为其分配必要的资源</li>
<li>进程同步：使多个进程相互协调，常用互斥与同步</li>
<li>进程通信：进程之间的信息交互，IPC</li>
<li>调度：作业调度与进程调度</li>
</ul>
<hr>
<ul>
<li><p>内存分配：为程序分配内存空间，提高存储器利用率，尽量减少内存碎片，允许正在运行的程序申请追加的内存空间</p>
<p>OS在实现内存分配时，可以采用静态和动态两种方式</p>
</li>
<li><p>内存保护：确保每道用户程序都仅在自己的内存空间运行，彼此互不干扰，不允许用户程序访问操作系统的程序和数据</p>
<p>需要采用内存保护机制，如设置两个界限寄存器</p>
</li>
<li><p>地址映射：在硬件的支持下，将线性地址空间中的逻辑地址转换为内存空间中与之相对应的物理地址</p>
</li>
<li><p>内存扩充：采用虚拟存储技术，从逻辑上扩展内存</p>
</li>
</ul>
<hr>
<ul>
<li>缓冲管理：在IO设备和CPU之间引入缓冲，可以有效地缓和CPU和IO设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统的吞吐量</li>
<li>设备分配：根据用户进程的IO请求，系统现有的资源情况以及分配策略，为之分配所需的设备</li>
<li>设备处理：设备驱动系统，实现CPU和设备控制器</li>
</ul>
<hr>
<ul>
<li>文件储存空间的管理：为文件分配外存空间，提高外存利用率</li>
<li>目录管理：为每个文件建立一个目录项，从外存中读取数据</li>
<li>文件的读写管理和保护：利用读写指针对文件进行读写操作，同时实现存取控制</li>
</ul>
<h2 id="1-5-OS的结构设计"><a href="#1-5-OS的结构设计" class="headerlink" title="1.5 OS的结构设计"></a>1.5 OS的结构设计</h2><ol>
<li><p>传统操作系统的结构：</p>
<ul>
<li><p>无结构操作系统</p>
</li>
<li><p>模块化操作系统</p>
<blockquote>
<p>将操作系统的功能分为若干个具有一定独立性的模块</p>
<p>内聚性:模块内部各部分之间的紧密程度,内聚性越高,模块独立性越强</p>
<p>耦合度:模块间相互联系和相互影响的程度,耦合度越低,模块独立性越好</p>
</blockquote>
</li>
<li><p>分层式结构OS</p>
</li>
</ul>
</li>
<li><p>客户/服务器模式</p>
</li>
<li><p>面向对象的程序设计</p>
</li>
<li><p>微内核OS结构</p>
<ul>
<li>足够小的内核</li>
<li>基于客户/服务器模式</li>
<li>应用机制与策略分离原理</li>
<li>采用面向对象技术</li>
</ul>
</li>
</ol>
<h1 id="2-进程的描述与控制"><a href="#2-进程的描述与控制" class="headerlink" title="2. 进程的描述与控制"></a>2. 进程的描述与控制</h1><h2 id="2-1-进程的控制"><a href="#2-1-进程的控制" class="headerlink" title="2.1 进程的控制"></a>2.1 进程的控制</h2><blockquote>
<p>在多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并具有间断性，因此通常的程序不能参与并发执行，因此引入进程概念</p>
<p>为了使参与执行的每个程序都能独立运行，在操作系统中必须配置一个专门的数据结构，即PCB</p>
<p>创建进程就是创建进程实体的PCB，PCB，程序段和相关的数据段组成了进程的实体</p>
</blockquote>
<ul>
<li>进程的特征：动态性，并发性，独立性，异步性</li>
<li>进程的三种基本状态：<ol>
<li>就绪状态（Ready）：进程已经被分配到除了CPU以外的所有必要资源，只要获得CPU就可以立即执行</li>
<li>执行状态（Running）：程序正在执行</li>
<li>阻塞状态（Block）：正在执行的进程由于发生某事件（如I/O请求）暂时无法继续执行的情况</li>
</ol>
</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200825141806354.png">

<ul>
<li>创建状态和终止状态：<ul>
<li>创建状态：创建一个空的PCB，并向PCB中填写用于控制和管理进程的信息，并为其分配运行必须的资源</li>
<li>终止状态：等待操作系统进行善后处理，最后将PCB清零返还系统</li>
</ul>
</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200825142642247.png">

<ul>
<li><p>挂起操作和进程状态的转换</p>
<blockquote>
<p>在许多系统中除了就绪执行和阻塞三种基本的状态之外，还引入了进程的挂起操作</p>
<p>当该操作作用于某个进程时，意味着此进程进入静止状态，暂停执行并且暂时不接受调度</p>
</blockquote>
</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200825144616995.png">

<h2 id="2-2-进程管理中的数据结构"><a href="#2-2-进程管理中的数据结构" class="headerlink" title="2.2 进程管理中的数据结构"></a>2.2 进程管理中的数据结构</h2><ol>
<li><p>操作系统中用于管理控制的数据结构：内存表，文件表，设备表，进程表</p>
</li>
<li><p>PCB的信息</p>
<ul>
<li>进程标识符：外部标识符，内部标识符</li>
<li>处理机状态：寄存器，指令计数器，用户栈指针</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li><p>进程控制块的组织方式：线性方式，链接方式，索引方式</p>
</li>
</ol>
<h2 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h2><blockquote>
<p>进程控制指进程管理中最基本的功能，主要包括创建新进程，终止已完成的进程，将发生异常情况而无法继续运行的进程置于阻塞状态，进程控制一般是由OS的内核中的原语来实现的。</p>
<p>操作系统内核主要包含了以下两大方面的内容：支撑功能，资源管理功能</p>
</blockquote>
<ul>
<li>进程的创建：创建进程的进程称为父进程，被创建的进程是子进程，子进程可以继续创建进程，组成了一个进程家族，引起创建进程的事件有：用户登录，作业调度，提供服务，应用请求</li>
<li>进程的终止：引起进程终止的时间：正常结束，异常结束，外界干预（操作系统，父进程），终止过程：根据进程标识符找到PCB，如果进程正在执行，终止执行状态，置调度标志为1，若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程，将被终止进程的所有资源归还给父进程，将被终止进程PCB从所在队列中移除</li>
<li>引起进程阻塞或者唤醒的事件：向系统请求共享资源失败，等待某种操作的完成，新数据尚未到达，等待新任务的到达</li>
</ul>
<h2 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h2><blockquote>
<p>进程同步机制的主要任务是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间按照一定的规则共享系统的资源。两种相互制约关系：简介相互制约关系，直接相互制约关系</p>
</blockquote>
<ul>
<li><p>临界资源：硬件资源等需要采用互斥方式实现共享</p>
</li>
<li><p>临界区：每个进程中访问临界资源的代码成为临界区</p>
</li>
<li><p>硬件同步机制</p>
<ol>
<li>关中断：在临界区执行时不会响应中断，从而不会发生进程调度</li>
<li>Test-and-Set指令实现互斥</li>
<li>使用Swap指令实现进程互斥</li>
</ol>
</li>
<li><p>信号量机制（整型信号量，记录型信号量，AND型信号量）</p>
</li>
<li><p>经典进程同步问题：生产者-消费者问题，哲学家进餐问题，读者-写者问题</p>
</li>
</ul>
<h2 id="2-5-进程通信IPC"><a href="#2-5-进程通信IPC" class="headerlink" title="2.5 进程通信IPC"></a>2.5 进程通信IPC</h2><ul>
<li><p>进程通信的类型</p>
<ol>
<li>共享存储器系统</li>
<li>管道通信系统：进程通过向管道文件发送字节流，共享数据</li>
<li>消息传递系统：直接通信和间接通信</li>
<li>客户机-服务器系统：套接字，远程过程调用和远程方法调用</li>
</ol>
</li>
<li><p>消息传递机制通信的实现方式</p>
<ol>
<li>直接消息传递系统：直接通信原语</li>
<li>信箱通信：属于间接通信方式，进程间的通信需要通过某种中间实体来完成该实体建立在随机存储器的公用缓冲区上，暂存发送进程发送给目标进程的消息，系统为信箱的创建和接收信息提供了原语</li>
</ol>
</li>
</ul>
<h2 id="2-6-线程的基本概念"><a href="#2-6-线程的基本概念" class="headerlink" title="2.6 线程的基本概念"></a>2.6 线程的基本概念</h2><blockquote>
<p>线程是比进程更小的基本单位，引入的目的是进一步提高程序的并发执行的程度</p>
</blockquote>
<ul>
<li>进程的两个基本属性：京城是一个可以拥有资源的独立单位，进程同时又是一个可独立调度和分派的基本单位</li>
<li>进程和线程的比较：<ol>
<li>调度的基本单位：在传统OS中，进程是能够运行的基本单位，每次被调度时都需要切换上下文，开销较大，引入线程后，将线程作为独立运行的基本单位，当线程切换时，仅需保存和设置少量的寄存器，切换代价小于进程，同时在同一进程中线程的切换不涉及进程的切换</li>
<li>并发性：在引入线程之后，不仅进程之间可以并发进行，并且在一个进程中的多个线程亦可以并发执行</li>
<li>拥有资源：进程可以拥有资源并作为拥有资源的一个基本单位，但线程本身没有系统资源，而是仅有一点必不可少的，能保证独立运行的资源，如TCB，进程除了拥有自己的少量资源外，还允许多个线程共享该线程所拥有的资源，属于同一个进程的所有线程都有相同的地址空间</li>
<li>独立性：在同一进程中的不同线程的独立性比不同进程之间的独立性低得多，每一个进程都有一个独立的地址空间和其他资源，而同一进程中的不同线程为了提高并发性，每个线程可以访问他们所属进程的地址空间的所有地址</li>
<li>系统开销：在创建和撤销进程时，系统都要位置分配和回收进程控制块和其他资源，OS的开销远大于线程创建和撤销时付出的开销</li>
<li>支持多处理机系统：对于多处理机系统，可以将多线程进程的多个线程分配到不同的处理机上，使其并行执行，即多线程</li>
</ol>
</li>
<li>线程运行的三个状态：执行状态，就绪状态，阻塞状态</li>
</ul>
<h2 id="2-7-线程的实现"><a href="#2-7-线程的实现" class="headerlink" title="2.7 线程的实现"></a>2.7 线程的实现</h2><ol>
<li>内核支持线程KST</li>
<li>用户级线程ULT</li>
<li>组合方式</li>
</ol>
<h1 id="3-处理机调度与死锁"><a href="#3-处理机调度与死锁" class="headerlink" title="3. 处理机调度与死锁"></a>3. 处理机调度与死锁</h1><h2 id="3-1-处理机调度的层次和调度算法的目标"><a href="#3-1-处理机调度的层次和调度算法的目标" class="headerlink" title="3.1 处理机调度的层次和调度算法的目标"></a>3.1 处理机调度的层次和调度算法的目标</h2><ul>
<li>处理机调度的层次：高级调度，低级调度，中级调度<ol>
<li>高级调度：又称长程调度，调度对象是作业，将外存中位于后被队列中的作业调入内存，为其创建进程，主要用于多批道处理系统</li>
<li>低级调度：调度对象是进程，主要功能是根据某种算法，决定就绪队列中的哪个进程应该获得处理机</li>
<li>中级调度：又称为内存调动，把暂时不需要的进程移动到外存等待，提高内存利用率</li>
</ol>
</li>
<li>处理机调度算法的共同目标是提高资源利用率，公平性，平衡性和策略强制执行</li>
</ul>
<h2 id="3-2-作业与作业调度"><a href="#3-2-作业与作业调度" class="headerlink" title="3.2 作业与作业调度"></a>3.2 作业与作业调度</h2><ul>
<li>作业：比程序更加广泛的概念，不仅包含了通常的程序和数据，还包含一份作业说明书，在多批道处理系统中，以作业为基本单位从外存调入内存</li>
<li>作业步：每个作业都需要若干个互相独立的顺序加工才能得到结果，每一步成为一个作业步</li>
<li>作业控制块：包含作业标识，用户名称，用户账号，和作业类型等的数据结构</li>
<li>作业运行的三个状态：收容状态，运行状态，完成状态</li>
<li>作业调度：<ol>
<li>先来先服务（FCFS）调度算法</li>
<li>短作业优先（SJF）调度算法：必须预知作业运行的时间，对长作业非常不利，不能保证紧迫性作业及时得到处理</li>
<li>优先级（PSA）调度算法</li>
<li>高响应比优先调度算法：优先级=（等待时间+要求服务时间）/要求服务时间</li>
</ol>
</li>
<li>进程调度任务：保护处理机的现场信息，按照某种算法选取进程，把处理器分配给进程</li>
<li>进程调度方式：非抢占方式，抢占方式</li>
<li>调度算法<ol>
<li>轮转调度算法：时间片轮转（RR）调度算法，系统的所有就绪进程按照FCFS策略排成一个就绪队列，在当前进程运行完成或者时间片用完时激活进程调度程序，若此时当前程序没有运行完将其送往调度程序的队末</li>
<li>优先级调度算法：分为抢占式和非抢占式，优先级为静态优先级或者动态优先级</li>
<li>多队列调度算法：将不同类型的进程固定分配在不同队列，实施不同的调度算法</li>
<li>多级反馈队列：设置多个就绪队列，并为每个就绪队列赋予不同的优先级，越前的队伍优先级越高，队伍优先级越高，时间片就越小，每个队伍都采用FCFS算法，当进程进入内存后先将其放入第一个队列的末尾，如果该进程能在规定的时间片内完成，便可撤离，否则进入第二队队尾等待，当进程最后被降级到最后一个队列时，采取RR方式运行。同时队列间按照优先级调度，当优先级高的队列空时，才会调度低优先级的队列。</li>
<li>基于公平原则的调度算法</li>
</ol>
</li>
</ul>
<h2 id="3-3-实时调度"><a href="#3-3-实时调度" class="headerlink" title="3.3 实时调度"></a>3.3 实时调度</h2><ul>
<li><p>实现实时调度的基本条件：提供实施调度的基本信息，系统处理能力抢，采用抢占式调度机制，具有快速切割机制</p>
</li>
<li><p>最早截止时间优先（EDF）算法：任务完成的截止时间越早，优先级越高</p>
</li>
<li><p>最低松弛度优先（LLF）算法：该算法在确定任务的优先级时，根据人物的紧急程度，任务的紧急程度越高，使其先执行</p>
</li>
<li><p>优先级倒置：</p>
<ol>
<li>优先级倒置的形成：高优先级进程和低优先级进程共享临界资源而被低优先级资源阻塞</li>
<li>优先级倒置的解决方案：动态优先级继承，即在高优先级进程进入临界区之后，如果有低优先级进程正在使用临界资源，则阻塞高优先级进程，使低优先级进程继承其优先级</li>
</ol>
</li>
</ul>
<h2 id="3-4-死锁"><a href="#3-4-死锁" class="headerlink" title="3.4 死锁"></a>3.4 死锁</h2><blockquote>
<p>竞争不可抢占性资源引起死锁</p>
<p>竞争可消耗性资源引起死锁</p>
<p>进程推进顺序不当引起死锁</p>
</blockquote>
<ul>
<li>死锁的定义：如果一组进程中的每一个进程都在等待该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件：<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不可抢占条件</li>
<li>循环等待条件</li>
</ol>
</li>
<li>处理死锁的方法：<ol>
<li>预防死锁：设置限制，破坏四种条件的产生</li>
<li>避免死锁：在资源的动态分配中加入某种方法防止系统进入不安全条件</li>
<li>检测死锁</li>
<li>解除死锁：撤销一些进程回收资源</li>
</ol>
</li>
</ul>
<h2 id="3-5-预防死锁"><a href="#3-5-预防死锁" class="headerlink" title="3.5 预防死锁"></a>3.5 预防死锁</h2><table>
<thead>
<tr>
<th>针对条件</th>
<th>措施</th>
</tr>
</thead>
<tbody><tr>
<td>“请求与保持”</td>
<td>所有协议在开始之前必须请求所有运行时需要的资源，进程在运行中逐步释放已经用完的资源</td>
</tr>
<tr>
<td>“不可抢占”</td>
<td>已经保持了不可抢占资源的进程在提出新的资源请求无法被满足时，必须释放已经保持的所有资源</td>
</tr>
<tr>
<td>“循环等待”</td>
<td>对资源进行线性排序，只能单向地请求资源</td>
</tr>
</tbody></table>
<h2 id="3-6-避免死锁（最大需求-已分配）"><a href="#3-6-避免死锁（最大需求-已分配）" class="headerlink" title="3.6 避免死锁（最大需求+已分配）"></a>3.6 避免死锁（最大需求+已分配）</h2><p>在死锁避免方法中，将系统的状态分为安全状态和不安全状态，在安全状态中可以避免发生死锁，因此应避免系统进入不安全状态</p>
<p>常利用银行家算法避免死锁，每一个新进程进入系统时，都要申明在运行过程中需要的每种资源的最大单元数目，系统在分配资源时需确定是否有足够的资源分配给该进程</p>
<h2 id="3-7-死锁的检测和排除"><a href="#3-7-死锁的检测和排除" class="headerlink" title="3.7 死锁的检测和排除"></a>3.7 死锁的检测和排除</h2><ul>
<li>死锁的检测：某状态的资源分配图不能完全简化则发生死锁</li>
<li>死锁的排除：终止所有进程，或逐个终止进程直到拥有足够的资源</li>
</ul>
<h1 id="4-存储器管理"><a href="#4-存储器管理" class="headerlink" title="4. 存储器管理"></a>4. 存储器管理</h1><h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h2><img src="https://blogpics.lenmain.cn/static/images/image-20200827141251528.png">

<blockquote>
<p>寄存器和主存储器又称为可执行存储器，与外存的访存机制不同</p>
<p>寄存器的访问速度最快，高速缓存介于寄存器和主存之间，磁盘缓存用户缓和磁盘IO和主存访问速度的不匹配</p>
</blockquote>
<h2 id="4-2-程序的装入和链接："><a href="#4-2-程序的装入和链接：" class="headerlink" title="4.2 程序的装入和链接："></a>4.2 程序的装入和链接：</h2><p>用户程序要在系统中运行，需要先装入内存，然后将其转变为一个可以执行的程序，需要以下步骤</p>
<ol>
<li>编译：由编译程序将用户程序编译成若干个目标模块</li>
<li>链接：由链接程序将编译后的一组目标模块以及他们需要的库函数链接在一起，形成一个完整的装入模块</li>
<li>装入：由装入程序将装入模块装入内存</li>
</ol>
<h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h2><blockquote>
<p>为了将用户程序装入内存，必须为其分配一个一定大小的内存空间</p>
<p>连续分配存储中代码和数据的逻辑地址相邻，体现在内存分配时物理地址的相邻</p>
<p>常用的连续分配方式分为四类：单一连续分配，固定分区分配，动态分区分配和动态可重定位分区分配</p>
</blockquote>
<ol>
<li><p>单一连续分配：在用户区内存中仅有一道用户程序（单任务操作系统）</p>
</li>
<li><p>固定分区分配：内存的用户空间划分成若干固定大小的分区，分区大小可以固定也可以不等</p>
</li>
<li><p>动态分区分配：根据进程的实际需要，动态地为之分配内存空间，涉及到分区分配中使用的数据结构，分区分配算法和分区的分配与回收操作三方面的问题</p>
<ul>
<li><p>数据结构：空闲分区表，空闲分区链</p>
</li>
<li><p>基于顺序搜索的动态分区分配算法</p>
<ol>
<li>首次适应（FF）算法</li>
<li>循环首次适应（NF）算法：从上次找到的空闲分区开始查找</li>
<li>最佳适应（BF）算法：空闲分区链按容量从小到大排列</li>
<li>最坏适应（WF）算法：:与BF相反，不易产生碎片</li>
</ol>
</li>
<li><p>基于索引搜索的动态动态分区分配算法</p>
<ol>
<li>快速适应算法</li>
<li>伙伴系统</li>
<li>哈希算法</li>
</ol>
</li>
</ul>
</li>
<li><p>动态可重定位分区分配</p>
</li>
</ol>
<h2 id="4-4-交换技术（swapping）"><a href="#4-4-交换技术（swapping）" class="headerlink" title="4.4 交换技术（swapping）"></a>4.4 交换技术（swapping）</h2><blockquote>
<p>将内存中暂时不用的程序或者数据换出到外存上，以便腾出足够的内存空间，再把已经具备运行条件的进程或者程序和数据换入内存</p>
</blockquote>
<ul>
<li>交换的类型：整体交换，页面交换</li>
</ul>
<h2 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h2><blockquote>
<p>将进程分散地装入到许多不相邻接的分区中，可以充分地利用内存空间，即离散式分配方式</p>
<p>分页存储管理方式，分段存储管理方式，段页式存储管理方式</p>
</blockquote>
<ol>
<li><p>分页存储管理的基本方法：</p>
<ul>
<li>页面和物理块：分页存储管理将进程的逻辑空间分成若干个页，并为各页编号，相应的也为内存空间分割编号，在进程分配内存时，以块为单位，将进程中的若干个页分别装入到多个可以不相邻的物理块中，易形成页内碎片</li>
<li>分页地址：分页地址包含页号和位移量两个部分，位移量即页内地址</li>
<li>页表：在分页系统中，系统为每个进程建立了一张页面映像表，简称页表，记录页号对应的内存块号，实现了页号到物理块号的地址映射</li>
</ul>
</li>
</ol>
<ol start="2">
<li>地址变换机构：实现从逻辑地址到物理地址的转换，借助页表完成</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200828133321097.png">




<img src="https://blogpics.lenmain.cn/static/images/image-20200828133353480.png">

<p>   ​        页表大部分滞留在内存中，系统保留一个页表寄存器，进程未执行时，页表的始址和页表长度保存在本进程的PCB中，当调度到该进程时，再将其装入页表寄存器，因此系统仅需一个页表寄存器，当进程要访问某个逻辑地址中的数据时，转换机构将有效地址分为页号和页内地址两个部分，以页号为索引去检索页表，若页表大于或等于页表长度，则发生越界中断，否则将页表始址和页表长度的乘积相加，得到该表项在页表中的位置，于是得到该页的物理块号，将其装入物理地址寄存器。为了提高地址变换效率，在高速缓存中增设快表。</p>
<ol start="3">
<li><p>访问内存的有效时间：从进程发出指定逻辑地址的访问要求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所花费的总时间</p>
</li>
<li><p>两级和多级快表</p>
<ul>
<li>两级页表：为离散分布的页表建立一张页表，称为外层页表，在每个页表项中记录了页表页面的物理块号</li>
</ul>
</li>
</ol>
<pre><code>&#123;% qnimg image-20200828135043309.png %&#125;</code></pre>
<ul>
<li>多级页表：多用于64位计算机</li>
</ul>
<ol>
<li>反置页表</li>
</ol>
<h2 id="4-6-分段存储管理方法"><a href="#4-6-分段存储管理方法" class="headerlink" title="4.6 分段存储管理方法"></a>4.6 分段存储管理方法</h2><blockquote>
<p>通常程序要分为若干个段，为了实现使用段号+段内偏移量的方式寻址，需要引入分段存储，为了方便起见，每个段用一个段号来代替 ，每个段都使用0开始编址，分段地址中的地址包括段号和段内地址。系统为每个分段分配一个连续的分区，进程中的各个段可以离散地装入到内存的不同分区中。段表中记录了某个段的段长和基址，进程可以通过段表找到对应的内存区</p>
</blockquote>
<ol>
<li>分段存储地址变换：</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200828154004388.png">

<ol>
<li><p>分段和分页的主要区别：</p>
<ul>
<li>页是信息的物理单位，采用分页存储方式是为了实现离散分配，实现系统管理的需要，对于用户是不可见的，而段则是信息的逻辑单位，含有相对完整的信息，用于更好地满足用户需求</li>
<li>页的大小固定且由系统决定，直接使用硬件实现，而段的长度不固定，由编译程序根据信息的性质进行划分</li>
<li>分页的用户地址空间是一维的，分页完全是系统的行为，因此在分页中用户程序的地址是属于单一的线性地址空间，而分段是用户的行为，在分段中用户的地址空间是二维的</li>
</ul>
</li>
<li><p>信息共享</p>
<p>分段系统易于进行段的共享，即允许若干个进程共享一个或多个分段</p>
</li>
</ol>
<h2 id="4-7-段页式存储管理方式"><a href="#4-7-段页式存储管理方式" class="headerlink" title="4.7 段页式存储管理方式"></a>4.7 段页式存储管理方式</h2><ol>
<li>基本原理：段号，段内页号，以及页内地址</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200828160434685.png">

<ol>
<li>地址变换过程</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200828160511890.png">

<h1 id="5-虚拟存储器"><a href="#5-虚拟存储器" class="headerlink" title="5. 虚拟存储器"></a>5. 虚拟存储器</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>具有请求调入功能和置换功能，能从逻辑上对内存的容量加以扩充的一种存储器系统</p>
<ul>
<li>虚拟存储器的特征：多次性，对换性，虚拟性</li>
<li>虚拟存储器的实现：分页请求系统，请求分段系统</li>
</ul>
<h2 id="5-2-请求分页存储管理方式"><a href="#5-2-请求分页存储管理方式" class="headerlink" title="5.2  请求分页存储管理方式"></a>5.2  请求分页存储管理方式</h2><ul>
<li><p>请求页表机制：除了页对应的物理块号，页表还应包含状态位（是否调入内存），访问字段，修改位，外村地址</p>
</li>
<li><p>缺页中断机制：在请求分页系统中，当所要访问的页面不在内存中时，便会产生缺页中断请求OS将页调入内存</p>
</li>
<li><p>地址变换机构</p>
</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200828163805721.png">

<ul>
<li><p>请求分页中的内存分配：最小物理块数的决定，内存分配策略，物理块分配算法</p>
</li>
<li><p>页面调入策略</p>
<ol>
<li>影响缺页率：页面大小，进程分到的内存块数，页面置换算法，程序固有特性</li>
<li>何时调入：预调页，请求调页</li>
<li>何处调入：兑换区（连续），文件区（离散）</li>
</ol>
</li>
</ul>
<h2 id="5-3-页面置换算法"><a href="#5-3-页面置换算法" class="headerlink" title="5.3 页面置换算法"></a>5.3 页面置换算法</h2><ol>
<li>最佳（optimal）置换算法：选择淘汰的是最长未来时间不会使用的</li>
<li>先进先出（FIFO）页面置换算法</li>
<li>最近最久未使用（LRU）置换算法</li>
<li>最少使用（LFU）置换算法：页面访问图和LRU完全相同</li>
<li>Clock置换算法</li>
<li>页面缓冲算法（PBA）</li>
</ol>
<h1 id="6-输入输出系统"><a href="#6-输入输出系统" class="headerlink" title="6. 输入输出系统"></a>6. 输入输出系统</h1><blockquote>
<p>I/O系统的主要对象是I/O设备和相应的设备控制器，其最主要的任务是，完成用户提出的I/O请求，提高I/O速率，以及提高设备的利用率，并能为更高层的进程方便地使用这些设备提供手段</p>
</blockquote>
<h2 id="6-1-I-O系统的功能，模型和接口"><a href="#6-1-I-O系统的功能，模型和接口" class="headerlink" title="6.1 I/O系统的功能，模型和接口"></a>6.1 I/O系统的功能，模型和接口</h2><ol>
<li><p>基本功能：隐藏物理设备的细节，与设备的无关性，提高处理机和I/O设备的利用率，对I/O设备进行控制，确保设备的正确共享，错误处理</p>
</li>
<li><p>I/O系统的层次结构和模型</p>
<ul>
<li>I/O软件组织分为四个层次：用户层I/O软件，设备独立性软件，设备驱动性软件，中断处理程序</li>
<li>I/O系统中各模块之间的层次：I/O系统的上（OS）下（硬件）接口</li>
</ul>
</li>
<li><p>I/O设备接口：块设备接口，流设备接口，网络设备接口</p>
</li>
</ol>
<h2 id="6-2-I-O设备和设备控制器"><a href="#6-2-I-O设备和设备控制器" class="headerlink" title="6.2 I/O设备和设备控制器"></a>6.2 I/O设备和设备控制器</h2><ol>
<li><p>I/O设备的分类：按照使用特性分类，按照传输速率分类</p>
</li>
<li><p>设备和控制器之间的接口：数据信号线，控制信号线，状态信号线</p>
</li>
<li><p>设备控制器：</p>
<ul>
<li>设备控制器的基本功能：接受和识别命令，数据交换，标识和报告设备的状态，地址识别，数据缓冲区，差错控制</li>
<li>设备控制器的组成：设备控制器和处理机的接口，设备控制器和设备的接口，I/O逻辑</li>
</ul>
</li>
<li><p>内存映像I/O</p>
<blockquote>
<p>驱动程序将抽象的I/O命令转换出一系列具体的命令，由控制器执行这些命令</p>
</blockquote>
<ul>
<li>利用特定的I/O指令</li>
<li>内存映像I/O</li>
</ul>
</li>
<li><p>I/O通道</p>
<p>虽然有设备控制器，当主机的外设很多时，CPU的负担很重，为此在CPU和设备控制器之间又增设了I/O通道，其主要目的是为了建立独立的I/O操作，使得一些原来有CPU执行的I/O任务由I/O通道来处理</p>
<ul>
<li>通道类型：字节多路通道，数组选择通道，数组多路通道</li>
</ul>
</li>
</ol>
<h2 id="6-3-中断机制和中断处理程序"><a href="#6-3-中断机制和中断处理程序" class="headerlink" title="6.3 中断机制和中断处理程序"></a>6.3 中断机制和中断处理程序</h2><ol>
<li><p>中断和陷入：外中断，内中断（陷入），主要区别是信号的来源来自CPU的内部和外部</p>
</li>
<li><p>中断向量表和中断优先级</p>
</li>
<li><p>多中断源的处理：屏蔽中断，嵌套中断</p>
</li>
<li><p>中断处理程序：但一个进程请求I/O操作时，该进程被挂起，知道I/O设备完成操作时，向CPU发送一个中断请求，CPU响应后转向中断处理程序，处理完成后解除相应进程的阻塞状态</p>
<ul>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断（当采用嵌套中断，可以处理优先级更高的中断）</li>
</ul>
</li>
</ol>
<h2 id="6-4-设备驱动程序"><a href="#6-4-设备驱动程序" class="headerlink" title="6.4 设备驱动程序"></a>6.4 设备驱动程序</h2><ol>
<li><p>设备驱动程序的功能：</p>
<ul>
<li>接受由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的底层操作序列</li>
<li>检查用户I/O请求的合法性，了解I/O设备的工作状态</li>
<li>发出I/O命令</li>
<li>及时响应由设备控制器发来的中断请求</li>
</ul>
</li>
<li><p>对I/O设备的控制方式：</p>
</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200829100149088.png">

<ul>
<li>使用轮询的可编程I/O方式</li>
<li>使用中断的可编程I/O方式</li>
<li>直接存储器访问方式：数据的传输单位是数据块，从设备直接送入主存，仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，进一步提高了CPU和I/O设备的并行操作程度</li>
</ul>
<h2 id="6-5-与设备无关的I-O软件"><a href="#6-5-与设备无关的I-O软件" class="headerlink" title="6.5 与设备无关的I/O软件"></a>6.5 与设备无关的I/O软件</h2><p>为了使实现设备独立性，在现代OS中增加了与设备无关的I/O软件，应用程序中使用的设备，不局限于某个具体的物理设备，为每个设备所需的设备驱动程序是与硬件紧密相关的软件，为了实现设备独立性，必须在设备驱动程序上设置一层软件，称为与设别无关的I/O软件</p>
<ul>
<li>从物理设备名到逻辑设备名，实现了逻辑设备名到物理设备名的转换</li>
<li>设备驱动程序的统一接口，缓冲管理，差错控制，对独立设备的分配和回收，独立于设备的逻辑数据块</li>
</ul>
<h2 id="6-6-用户层的I-O软件"><a href="#6-6-用户层的I-O软件" class="headerlink" title="6.6 用户层的I/O软件"></a>6.6 用户层的I/O软件</h2><ol>
<li><p>系统调用和库函数</p>
<p>用户态的应用无法直接调用系统态中的OS过程，可以通过系统调用间接调用OS中的I/O过程，对I/O设备进行操作</p>
</li>
</ol>
<h2 id="6-7-缓冲区管理"><a href="#6-7-缓冲区管理" class="headerlink" title="6.7 缓冲区管理"></a>6.7 缓冲区管理</h2><ol>
<li><p>缓冲的引入</p>
<ul>
<li>缓和CPU和I/O设备间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽CPU中断时间的限制</li>
<li>解决数据粒度不匹配</li>
<li>提高CPU和I/O设备的并行性</li>
</ul>
</li>
<li><p>单缓冲区，双缓冲区，环形缓冲区</p>
</li>
</ol>
<h2 id="6-8-磁盘存储器的性能和调度"><a href="#6-8-磁盘存储器的性能和调度" class="headerlink" title="6.8 磁盘存储器的性能和调度"></a>6.8 磁盘存储器的性能和调度</h2><ol>
<li><p>数据的组织和形式：磁盘设备可包含多个物理盘片，每个磁盘片可包含两个盘面，每个盘面有若干个磁道，磁被分为多个扇区</p>
</li>
<li><p>磁盘的类型：固定头磁盘，移动头磁盘</p>
</li>
<li><p>磁盘访问时间：寻道时间+旋转延迟时间+传输时间</p>
</li>
<li><p>早期的磁盘调度算法：</p>
<ul>
<li>先来先服务（FCFS）</li>
<li>最短寻道时间优先（SSTF）</li>
</ul>
</li>
<li><p>基于扫描的磁盘调度算法</p>
<ul>
<li>扫描（SCAN）算法</li>
<li>循环扫描算法（CSCAN）：规定单向扫描</li>
<li>NStepSCAN和FSCAN算法</li>
</ul>
</li>
</ol>
<h1 id="7-文件管理"><a href="#7-文件管理" class="headerlink" title="7. 文件管理"></a>7. 文件管理</h1><h2 id="7-1-文件和文件系统"><a href="#7-1-文件和文件系统" class="headerlink" title="7.1 文件和文件系统"></a>7.1 文件和文件系统</h2><ol>
<li>文件系统的层次结构</li>
<li>文件操作</li>
</ol>
<h2 id="7-2-文件的逻辑结构"><a href="#7-2-文件的逻辑结构" class="headerlink" title="7.2 文件的逻辑结构"></a>7.2 文件的逻辑结构</h2><p>文件有两种文件结构：逻辑结构，物理结构</p>
<p>按照文件的组织形式可以分为顺序文件，索引文件和索引顺序文件</p>
<ul>
<li>顺序文件：串结构，顺序结构</li>
<li>索引文件：按照关键字建立索引，可以具有多个索引表</li>
<li>索引顺序文件：以及索引顺序文件，两级索引顺序文件</li>
</ul>
<h2 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3 文件目录"></a>7.3 文件目录</h2><ol>
<li><p>文件控制块（FCB）</p>
<ul>
<li>基本信息：文件名，文件物理位置，文件逻辑结构，文件物理结构</li>
<li>存取控制信息</li>
<li>使用信息类</li>
</ul>
</li>
<li><p>索引节点：每个文件都有一个唯一的磁盘索引节点</p>
</li>
<li><p>简单的文件目录：单级文件目录，两级文件目录</p>
</li>
<li><p>树形结构目录</p>
</li>
</ol>
<h2 id="7-4-文件共享"><a href="#7-4-文件共享" class="headerlink" title="7.4 文件共享"></a>7.4 文件共享</h2><ul>
<li>基于有向无循环图</li>
<li>利用符号链</li>
</ul>
<h2 id="7-5-文件保护"><a href="#7-5-文件保护" class="headerlink" title="7.5 文件保护"></a>7.5 文件保护</h2><p>为了确保文件系统的安全，主要采取三方面的措施：</p>
<ol>
<li>通过存取控制，防止人为造成的文件不安全</li>
<li>通过系统容错技术，防止系统部分的故障造成的文件不安全</li>
<li>建立后备系统，防止由于自然原因的不安全</li>
</ol>
<hr>
<ul>
<li>保护域，访问矩阵</li>
</ul>
<h1 id="8-磁盘存储器的管理"><a href="#8-磁盘存储器的管理" class="headerlink" title="8. 磁盘存储器的管理"></a>8. 磁盘存储器的管理</h1><h2 id="8-1-外存的组织方式"><a href="#8-1-外存的组织方式" class="headerlink" title="8.1 外存的组织方式"></a>8.1 外存的组织方式</h2><ul>
<li>连续组织方式，链接组织方式，索引组织方式</li>
</ul>
<ol>
<li><p>连续组织方式</p>
<p>连续组织模式又称为连续分配模式，要求为每一个文件分配一组相邻接的盘块，通常位于同意磁道上，读取时不必移动磁头，顺序访存快且速度快，单易产生外部碎片，必须事先知道文件的长度且不能灵活地删除或者插入记录，对于动态增长的文件很难预先知道文件的最终大小</p>
</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200830152710458.png">

<ol>
<li><p>链接组织方式</p>
<p>为文件分配不连续的盘块，再通过每个盘块上的指针，将属于同一文件的离散的盘块链接成一个链表，消除了外部碎片，且插入删除都很容易</p>
</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200830153507588.png">

<ol>
<li><p>隐式链接：在文件目录的每个目录项中含有指向链接文件第一个盘块和最后一个盘块的指针，每个盘块包含下一个盘块的指针</p>
</li>
<li><p>显示链接：通过FAT表显式记录各物理块的链接，显著提高了检索效率，减少了访问磁盘的次数</p>
<blockquote>
<p>FAT技术：FAT12,FAT16,FAT32</p>
</blockquote>
</li>
</ol>
<ol>
<li><p>索引组织方式：</p>
<ul>
<li>单极索引组织方式</li>
</ul>
</li>
</ol>
<img src="https://blogpics.lenmain.cn/static/images/image-20200830154629217.png">

<ul>
<li>多级索引组织方式</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200830154641327.png">

<ul>
<li>增量式索引组织方式</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200830154659723.png">

<h2 id="8-2-文件存储空间的管理"><a href="#8-2-文件存储空间的管理" class="headerlink" title="8.2 文件存储空间的管理"></a>8.2 文件存储空间的管理</h2><ul>
<li><p>空闲表法和空闲链表法</p>
<p>使用方式和内存的动态分配相似，动态链表包括空闲盘块链和空闲盘区链</p>
</li>
<li><p>位示图法</p>
<p>利用二进制的一位表示磁盘的一个盘块的使用情况，形成一个二维数组表示每个盘块是否已经被分配，称为位示图</p>
<p>盘块的分配：在位示图中找到足够的未被分配的盘块，根据位示图中的行号和列号得到盘号，并更改其标志位</p>
<p>盘块的回收：根据盘号得到其在位示图中的位置，修改位示图</p>
</li>
<li><p>成组链接法</p>
</li>
</ul>
<img src="https://blogpics.lenmain.cn/static/images/image-20200831090224758.png">

<h2 id="8-3-提高磁盘I-O速度的途径"><a href="#8-3-提高磁盘I-O速度的途径" class="headerlink" title="8.3 提高磁盘I/O速度的途径"></a>8.3 提高磁盘I/O速度的途径</h2><blockquote>
<p>改进对文件的访问速度，可以从三方面入手：</p>
<ol>
<li>改进文件的目录结构以及检索目录的方法减少对文件的查找时间</li>
<li>选取好的文件存储结构，以提高对文件的访问速度</li>
<li>提高磁盘的I/O速度，能将文件中的数据快速地从磁盘传送到内存中</li>
</ol>
</blockquote>
<ol>
<li><p>磁盘高速缓存：在内存中为磁盘盘块设置一个缓存区，访问磁盘的请求会先访问缓存区</p>
<ul>
<li>数据交付方式：数据交付，指针交付</li>
<li>置换算法：访问频率，可预见性，数据的一致性</li>
<li>周期性写回磁盘</li>
</ul>
</li>
<li><p>提前读</p>
</li>
<li><p>延迟写</p>
</li>
<li><p>优化物理块的分布</p>
</li>
<li><p>虚拟盘</p>
</li>
<li><p>廉价磁盘冗余阵列</p>
</li>
</ol>
<h2 id="8-4-提高磁盘可靠性的技术"><a href="#8-4-提高磁盘可靠性的技术" class="headerlink" title="8.4 提高磁盘可靠性的技术"></a>8.4 提高磁盘可靠性的技术</h2><ul>
<li>第一级容错技术：双份目录和双份文件分配表</li>
<li>第二级容错技术：磁盘镜像，磁盘双工</li>
<li>基于集群技术的容错功能</li>
<li>后备系统</li>
</ul>
<h1 id="9-操作系统接口"><a href="#9-操作系统接口" class="headerlink" title="9. 操作系统接口"></a>9. 操作系统接口</h1><ul>
<li><p>用户接口：命令行接口，图形界面接口</p>
</li>
<li><p>shell命令语言</p>
</li>
<li><p>系统调用的概念和类型</p>
<p>通常情况下OS的内核运行在系统态，而应用程序运行在用户态</p>
<ul>
<li>系统态和用户态：特权指令运行在系统态，非特权指令运行在用户态，在实际运行过程中，处理机会在系统态和用户态之间切换</li>
<li>系统调用：使应用程序间接调用OS中的相关过程，通过中断机制实现</li>
<li>系统调用的类型：进程控制类系统调用，文件操纵类系统调用，进程通信类系统调用</li>
</ul>
</li>
</ul>
<h1 id="10-多处理机操作系统"><a href="#10-多处理机操作系统" class="headerlink" title="10. 多处理机操作系统"></a>10. 多处理机操作系统</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">lenmain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://vercel-hexo-ten.vercel.app/2020/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/">https://vercel-hexo-ten.vercel.app/2020/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/18/hello-world/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">计算机组成考研笔记</div></div></a></div></nav></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lenmain</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>